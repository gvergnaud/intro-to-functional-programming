<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Intro To Functional Programming</title>
    <link rel="stylesheet" href="./css/reveal.css" />
    <link rel="stylesheet" href="./css/theme/solarized.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/atom-one-dark.css" />
    <link rel="stylesheet" href="./css/print/paper.css" type="text/css" media="print" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section  data-markdown><script type="text/template">

### Une petite introduction au
## Functional Programming

<p style="font-size:.7em">Slides: https://gvergnaud.github.io/intro-to-functional-programming</p>
</script></section><section  data-markdown><script type="text/template">
##  Objectifs

- Comprendre ce qui se cache sous le terme "Functional"

- Donner des pistes à explorer

</script></section><section  data-markdown><script type="text/template">
## Petites questions
(vite fait)

</script></section><section  data-markdown><script type="text/template">

<h2 style="color: white !important; text-shadow: 0px 3px 15px rgba(0,0,0,.5)">
  Pourquoi ?
</h2>


<!-- .slide: data-background="http://i.giphy.com/1M9fmo1WAFVK0.gif" -->
</script></section><section  data-markdown><script type="text/template">
- de nouveaux frameworks tous les ans

- ceux des années précédentes deviennent obsolètes

- Que doit on apprendre qui nous serve à long terme ?

</script></section><section  data-markdown><script type="text/template">
## C'est JS-Fatiguant ?

</script></section><section  data-markdown><script type="text/template">
## Solution

- Arrêter de passer du temps à apprendre des **API**

- Mieux comprendre les fondamentaux du langage

- Se concentrer sur les **design patterns**

</script></section><section  data-markdown><script type="text/template">
<h3 style="color: white !important; text-shadow: 0px 3px 15px rgba(0,0,0,.5)">
  MPJME - How to stay relevant as a developer
</h3>

<p style="color: white !important; text-shadow: 0px 3px 15px rgba(0,0,0,.5)">
  [https://www.youtube.com/watch?v=ZZUY37RQS-k](https://www.youtube.com/watch?v=ZZUY37RQS-k)
</p>


<!-- .slide: data-background="resources/mpjme-relevant.png" -->
</script></section><section  data-markdown><script type="text/template">
### la promesse du functional programming

</script></section><section  data-markdown><script type="text/template">
un code avec

### Moins de bug
parce que plus facile à comprendre

### en moins de temps
parce que plus facile à réutiliser

</script></section><section  data-markdown><script type="text/template">
>“Developers proficient in functional programming are going to be in large demand in the very near future.”

**Eric Elliott** - [_The Two pillars of Javascript - Part 2_](https://medium.com/javascript-scene/the-two-pillars-of-javascript-pt-2-functional-programming-a63aa53a41a4)

</script></section><section  data-markdown><script type="text/template">
### Quelque langage functionnels

Lisp, ML,


Haskell, Scala, Erlang, Elixir, Clojure, OCaml…


----------------

**Qui compilent en JS**

Reason, Elm, ClojureScript

----------------

**Dans une moindre mesure**

le JS

</script></section><section  data-markdown><script type="text/template">
## Mais

on peut faire du fonctional dans *presque* tous les languages.

Ruby, Python, ..., même PHP !

</script></section><section  data-markdown><script type="text/template">

<h2 style="color: white !important; text-shadow: 0px 3px 15px rgba(0,0,0,.5)">
  Ok mais c'est quoi ?
</h2>


<!-- .slide: data-background="http://i.giphy.com/cx5UoGpRwLra0.gif" -->
</script></section><section  data-markdown><script type="text/template">
Préférer un style **déclaratif** à un style impératif

+

découper son code en petites **fonctions** réutilisables et composables.

+

Ne **jamais** mutter les données


<aside class="notes"><p>Ça permet de monter facilement en abstraction et d’arreter de tout micro manager.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## I
## Impératif vs Déclaratif

</script></section><section  data-markdown><script type="text/template">
###  Filtrer un tableau

Impératif :

```js
const users = [{ age: 20 }, { age: 31 }, { age: 17 }]

let oldUsers = []
for (let i = 0; i < users.length; i++) {
	const currentUser = users[i]
	if (currentUser.age > 30) oldUsers.push(currentUser)
}

console.log(oldUsers)
// => [{ age: 31 }]
```


Oulala qu'est ce que ça micromanage


<aside class="notes"><p>Micro management =</p>
<ul>
<li>déclaration de variables temporaire,</li>
<li>for loops,</li>
<li>if statements</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
### les symptomes de l'impératif

- déclaration de variables temporaires
- mutation de données
- des statements
  - for loops
  - if/else statements

</script></section><section  data-markdown><script type="text/template">
####  Filtrer un tableau

Déclaratif :


```js
const oldUsers = filter(user => user.age > 30, users)

console.log(oldUsers)
// => [{ age: 31 }]
```

</script></section><section  data-markdown><script type="text/template">


<!-- .slide: data-background="http://i.giphy.com/sN4xqr7YG4pm8.gif" -->
</script></section><section  data-markdown><script type="text/template">
####  Filtrer un tableau

Déclaratif :


```js
const oldUsers = filter(user => user.age > 30, users)

console.log(oldUsers)
// => [{ age: 31 }]
```

On va **décrire** le comportement du programme

plutôt que de dire ce qu'il se passe

à chaque étape de la boucle.

Mais ou est donc définie la function filter ?

</script></section><section  data-markdown><script type="text/template">
**Le déclaratif est construit sur de l’impératif.**

```js
function filter(predicate, xs) {
	let out = []
	for (let i = 0; i < xs.length; i++) {
		if (predicate(xs[i])) out.push(xs[i])
	}
	return out
}
```


filter est ce qu'on appelle une **Higher Order Function**

</script></section><section  data-markdown><script type="text/template">
## Higher Order Function

> “Its like the word Quintessential :

> when you say it, it just makes you feel smart.”

@mpjme

[Youtube - Higher Order Functions](https://www.youtube.com/watch?v=BMUiFMZr7vk)

</script></section><section  data-markdown><script type="text/template">
### Higher Order Function

Une fonction qui :

- va **abstraire** un bout de code **générique**

- va prendre une autre fonction en paramètre


cette deuxième fonction va **décrire** le comportement **spécifique** de la première.

</script></section><section  data-markdown><script type="text/template">
### Je vous ai menti
(un peu)

On peut aussi faire des boucles de manière déclarative




```js
const filter = (f, [x, ...rest]) =>
	rest.length
		? f(x) ? [x, ...filter(f, rest)] : filter(f, rest)
		: f(x) ? [x] : []
```


grâce à la recursion !

</script></section><section  data-markdown><script type="text/template">
**Filter est build-in sur Array.prototype**
```js
const oldUsers = users.filter(user => user.age > 30)
```

</script></section><section  data-markdown><script type="text/template">
### Transformer un tableau

>C'est à dire transformer chacun des items d'un tableau pour en créer un nouveau.

Impératif :

```js
const users = [{ age: 20 }, { age: 31 }, { age: 17 }]

let userAges = []
for (let i = 0; i < users.length; i++) {
	userAges.push(users[i].age)
}

console.log(userAges)
// => [20, 31, 17]
```

</script></section><section  data-markdown><script type="text/template">
####  Transformer un tableau

Déclaratif : la méthode **map()**

```js
const userAges = users.map(user => user.age)
console.log(userAges)
// => [20, 31, 17]
```

OU

```js
const userAges = map(user => user.age, users)

console.log(userAges)
// => [20, 31, 17]
```

</script></section><section  data-markdown><script type="text/template">
####  Transformer un tableau

implémentation de map

```js
function map(mapper, xs) {
	let out = []
	for (let i = 0; i < xs.length; i++) {
		out.push(mapper(xs[i]))
	}
	return out
}
```

ou avec recursion
```js
const map = (f, [x, ...rest]) =>
  rest.length ? [f(x), ...map(rest)] : [f(x)]
```

</script></section><section  data-markdown><script type="text/template">
###  Accumuler un tableau

>C'est à dire transformer les items d'un tableau en une seule valeur.


Impératif :

```js
const numbers = [20, 31, 17]

let sum = 0
for (let i = 0; i < numbers.length; i++) {
	sum = sum + numbers[i]
}

console.log(sum)
// => 68
```

</script></section><section  data-markdown><script type="text/template">
#### Accumuler un tableau

Déclaratif : la méthode **reduce()**

```js
const sum = numbers.reduce((acc, num) => acc + num, 0)

console.log(sum)
// => 68
```

OU

```js
const sum = reduce((acc, num) => acc + num, 0, numbers)

console.log(sum)
// => 68
```

</script></section><section  data-markdown><script type="text/template">
#### Accumuler un tableau

Implémentation de reduce

```js
function reduce(reducer, seed, xs) {
  let out = seed
  for (let i = 0; i < xs.length; i++) {
    out = reducer(out, xs[i])
  }
  return out
}
```

Ou avec recursion

```js
const reduce = (f, acc, [x, ...rest]) =>
  rest.length ? reduce(f, f(acc, x), rest) : f(acc, x)
```

</script></section><section  data-markdown><script type="text/template">
### Chainer ces modifications

C'est maintenant que ça prend tout son sens...

</script></section><section  data-markdown><script type="text/template">
```js
// users :: [ { name :: String, age :: Int } ]

const name = 'Kevin'
let averageAge = 0
let filteredUsers = []

for (let i = 0; i < users.length; i++) {
  const user = users[i]
  if (user.name === name) filteredUsers.push(user)
}

for (let j = 0; j < filteredUsers.length; j++) {
  const user = filteredUsers[j]
  averageAge = averageAge + user.age / filteredUsers.length
}
```


Qu'est ce que ça fait en un coup d'oeil ?

</script></section><section  data-markdown><script type="text/template">


<!-- .slide: data-background="http://i.giphy.com/tO5ddHjpXB6lG.gif" -->
</script></section><section  data-markdown><script type="text/template">
```js
const averageAge = users
  .filter(user => user.name === 'Kevin')
  .map(user => user.age)
  .reduce((acc, age, _, ages) => acc + age / ages.length, 0)
```

Et maintenant ?

</script></section><section  data-markdown><script type="text/template">
### En conclusion

- **L'Impératif, visuellement, c'est pas facile.**

la spécificité du bout de code est noyée dans les détails d'implémentation génériques.

</script></section><section  data-markdown><script type="text/template">
#### En conclusion

- **Impératif = code peu réutilisable**

nos boucles sont spécifiquement faite pour notre problème actuel.

</script></section><section  data-markdown><script type="text/template">
#### En conclusion

- **Impératif = code complexe**

</script></section><section  data-markdown><script type="text/template">
<h2 style="color: white !important; text-shadow: 0px 3px 15px rgba(0,0,0,.5)">
  Simplicity vs Complexity
</h2>


<p style="color: white !important; text-shadow: 0px 3px 15px rgba(0,0,0,.5)">
  Rich Hickey - [Simple Made Easy](https://www.youtube.com/watch?v=rI8tNMsozo0)
</p>


<!-- .slide: data-background="resources/simple-made-easy.png" -->
</script></section><section  data-markdown><script type="text/template">
# T.P.

### Parser de la NASA !

</script></section><section  data-markdown><script type="text/template">
## II
## Des petites functions réutilisables

</script></section><section  data-markdown><script type="text/template">
### fonction pure

>une fonction pure (ou stateless) est une fonction qui respecte quelques petites règles.

</script></section><section  data-markdown><script type="text/template">
#### une fonction pure

prend des paramètres et retourne un résultat

```js
// Pure
const add = (a, b) => a + b
add(2, 2)
// => 4

// Impure
const add = (a, b, cb) => {
  cb(a + b)
}
add(2, 2, v => console.log(v))
// => undefined
// "4"
```

</script></section><section  data-markdown><script type="text/template">
#### une fonction pure

n'altère pas les paramètres qui lui sont passés


```js
// Pure
const addValue = (arr, v) => arr.concat(v)
addValue([1, 2, 3], 4)
// => [1, 2, 3, 4]


// Impure
const addValue = (arr, v) => {
  arr.push(v)
}

let myArray = [1, 2, 3]
addValue(myArray, 4)
// => undefined
// myArray === [1, 2, 3, 4]

```

</script></section><section  data-markdown><script type="text/template">
#### une fonction pure

n'intéragit pas avec le scope dans lequel elle se trouve

```js
const number = 3

// Pure
const isOdd = x => !(x % 2)
isOdd(number)
// => true

// Impure
const isOdd = () => !(number % 2)
isOdd()
// => true

```

</script></section><section  data-markdown><script type="text/template">
#### une fonction pure

n'a pas d'effet de bord


```js
// Impure
const getUsers = (callback) => {
  fetch(`/user`).then(callback)
}
```

</script></section><section  data-markdown><script type="text/template">
### Pourquoi c'est chouette ?


Pour les mêmes arguments données la function retournera **toujours** la même chose. On peut Memoize!


Facile à **comprendre** car pas de dépendences externes.


Pas de comportement chelou.

</script></section><section  data-markdown><script type="text/template">


<!-- .slide: data-background="http://i.giphy.com/tIeCLkB8geYtW.gif" -->
</script></section><section  data-markdown><script type="text/template">
#### function pure

## Fonction as Data

</script></section><section  data-markdown><script type="text/template">
### Ptit test


```js
const isThisPure = x => x * 2
```

alors ? pure ou pas pure ?

</script></section><section  data-markdown><script type="text/template">
#### Ptit test


```js
const isThisPure = str => {
	window.title = str
}
```

</script></section><section  data-markdown><script type="text/template">
#### Ptit test


```js
const isThisPure = str => {
	const title = `AppName - ${str}`
	return () => window.title = title
}
```

</script></section><section  data-markdown><script type="text/template">
### “Mais avec ça on peut rien faire !”

</script></section><section  data-markdown><script type="text/template">
#### Oui, c'est vrai.

</script></section><section  data-markdown><script type="text/template">
Ce qui nous intéresse dans un programme c'est les side effects.

- Render quelque chose sur la page
- Réagir à des events
- Écrire dans une db

On va pas loin avec des fonctions pures.

</script></section><section  data-markdown><script type="text/template">
Mais les side effects sont aussi les plus susceptibles de bugger.

</script></section><section  data-markdown><script type="text/template">
### Flow d'un code functional

```

    SideEffect -> Pure -> SideEffect
_
```

Pousser les side effects aux bords de notre code.

<aside class="notes"><p>Demo -&gt;</p>
<pre><code class="lang-js">getData().then(app)

const app = compose(
  render
  map(etc)
)
</code></pre>
</aside></script></section><section  data-markdown><script type="text/template">
#### Flow d'un code functional


Par exemple :

```

    GetData -> Computation -> Render
_
```
Computation = la logique de notre app

</script></section><section  data-markdown><script type="text/template">
#### Flow d'un code functional



```

    render(compute(getData()))
_
```

Ca vous rappelle pas quelque chose ?

</script></section><section  data-markdown><script type="text/template">
#### Flow d'un code functional



```

    view(controller(model()))
_
```

</script></section><section  data-markdown><script type="text/template">
```

    view(controller(model()))
_
```

Bon c'est un peu tiré par les cheveux.

Mais on a bien nos trois parties

les **données**, le **traitement** et la **vue**.

</script></section><section  data-markdown><script type="text/template">
<h2 style="color: white !important; text-shadow: 0px 3px 15px rgba(0,0,0,.5)">
  composition
</h2>


<!-- .slide: data-background="http://i.giphy.com/mGj3SVN7xbPQ4.gif" -->
</script></section><section  data-markdown><script type="text/template">
## Mais qu'est ce donc ?

> Soit deux fonction `f(x)` et `g(x)`

> leur function composée est `f(g(x))`

</script></section><section  data-markdown><script type="text/template">
<h2 style="color: white !important; text-shadow: 0px 3px 15px rgba(0,0,0,.5)">
  des maths :(
</h2>


<!-- .slide: data-background="resources/DontFearTheMonad.png" -->
</script></section><section  data-markdown><script type="text/template">
##  Mais non !

</script></section><section  data-markdown><script type="text/template">
<h2 style="color: white !important; text-shadow: 0px 3px 15px rgba(0,0,0,.5)">
  des legos ! :)
</h2>


<!-- .slide: data-background="resources/lego.jpg" -->
</script></section><section  data-markdown><script type="text/template">
#### Je m'explique

L'idée est de connecter les functions entre elles

en passant le resultat d'un fonction en paramètre à la suivante.

```js
import { compose } from 'ramda';

const double = x => x * 2
const tripple = x => x * 3

// composition ->

const sixtuple = compose(double, tripple)

console.log(sixtuple(7))
// 42

```

</script></section><section  data-markdown><script type="text/template">
Pareil que

```js
const double = x => x * 2
const tripple = x => x * 3

const sixtuple = x => double(tripple(x))

console.log(sixtuple(7))
// 42

```

</script></section><section  data-markdown><script type="text/template">
Pareil que

```js
const sixtuple = x => {
  const trippled = tripple(x)
  const result = double(trippled)
  return result
}

console.log(sixtuple(7))
// 42
```

</script></section><section  data-markdown><script type="text/template">
#### Composition

Comme si on emboitait des légos !

</script></section><section  data-markdown><script type="text/template">
> “The way to control Complexity

>is Compositionality.”

Brian Beckman: [Don't Fear The Monad](https://www.youtube.com/watch?v=ZhuHCtR3xq8)

</script></section><section  data-markdown><script type="text/template">
#### (Parenthèse)

### Hindley-Milner Type Notation

</script></section><section  data-markdown><script type="text/template">
#### Hindley-Milner Type Notation

Signature de function qui décrit son type

```hs

  multiplyByTwo :: Int -> Int
  const multiplyByTwo = x => x * 2
_
```

</script></section><section  data-markdown><script type="text/template">
#### Hindley-Milner Type Notation

```hs

  length :: String -> Int
  const length = str => str.length
_
```

</script></section><section  data-markdown><script type="text/template">
### Je l'ai pas inventé !

Il y a même un moteur de recherche pour ça :

![HOOGLE](resources/hoogle.png)
[HOOGLE](https://www.haskell.org/hoogle/)


Haskell Function Search Engine

</script></section><section  data-markdown><script type="text/template">
#### Hindley-Milner Type Notation

C'est très pratique pour composer des functions.

```hs
length :: String -> Int
const length = str => str.length

isGreaterThanTen :: Int -> Bool
const isGreaterThanTen = x => x > 10
```

quel sera la signature de

```js
compose(isGreaterThanTen, length)
```
?

</script></section><section  data-markdown><script type="text/template">
#### Hindley-Milner Type Notation


```js
const isLengthGreaterThanTen = compose(length, isGreaterThanTen)
```

```hs
(String -> Int) + (Int -> Bool) = String -> Bool
```

donc

```hs
isLengthGreaterThanTen :: String -> Bool
```

</script></section><section  data-markdown><script type="text/template">
#### la composition

## Le problème

>comment on fait quand les functions prènnent plusieurs arguments ?

</script></section><section  data-markdown><script type="text/template">
<h2 style="color: white !important; text-shadow: 0px 3px 15px rgba(0,0,0,.5)">
  curry
</h2>
<p style="color: white !important; text-shadow: 0px 3px 15px rgba(0,0,0,.5)">
  la solution à tous nos soucis
</p>


<!-- .slide: data-background="resources/curry.jpg" -->
</script></section><section  data-markdown><script type="text/template">
## Le Currying

> une fonction curriée est une function qui, lorsqu'on ne lui donne pas tous ses
 paramètres, renvoie une function qui prendra le reste.

</script></section><section  data-markdown><script type="text/template">
### Le Currying


```js
import { curry } from 'ramda';

const sumOfFour = (a, b, c, d) => a + b + c + d

sumOfFour(1)
// => NaN

const curriedSumOfFour = curry(sumOfFour)
curriedSumOfFour(1)
// => (b, c, d) => 1 + b + c + d
_
```

</script></section><section  data-markdown><script type="text/template">
### Le Currying

Presque pas besoin :

```js

const sumOfFour = a => b => c => d => a + b + c + d

sumOfFour(1)
// => (b, c, d) => 1 + b + c + d
_
```
en ES6, les `arrow functions` facilitent la syntaxe

des functions qui retournent des functions.

</script></section><section  data-markdown><script type="text/template">
### Le Currying

Mais la function `curry` nous permet de passer

aussi plusieurs paramètres d'un coup si on veut :

```js

const sumOfFour = curry((a, b, c, d) => a + b + c + d)

sumOfFour(1, 2)
// => (c, d) => 1 + 2 + c + d

const sumOfFour = a => b => c => d => a + b + c + d

sumOfFour(1, 2)
// => (b, c, d) => 1 + b + c + d
// :(
_
```

</script></section><section  data-markdown><script type="text/template">
#### (Parenthèse)

<h2>
  <span style="text-transform: capitalize !important;">Haskell </span>
  <span style="text-transform: capitalize !important;">Curry </span>
</h2>

</script></section><section  data-markdown><script type="text/template">
<h1 style="color: white !important; text-shadow: 0px 3px 15px rgba(0,0,0,.5)">
  T.P.
</h1>

<h3 style="color: white !important; text-shadow: 0px 3px 15px rgba(0,0,0,.5)">
  Back to the nasa
</h3>


<!-- .slide: data-background="http://i.giphy.com/oZmk8DX9H0foA.gif" -->
</script></section><section  data-markdown><script type="text/template">
#### reprenons

</script></section><section  data-markdown><script type="text/template">
<h2 style="color: white !important; text-shadow: 0px 3px 15px rgba(0,0,0,.5)">
  Des données immutables
</h2>


<!-- .slide: data-background="resources/statue.jpg" -->
</script></section><section  data-markdown><script type="text/template">
#### Des données immutables

> En functional programming lorsque l'on assigne une variable, ça veut dire
qu'elle ne changera plus jamais.

</script></section><section  data-markdown><script type="text/template">
#### Des données immutables

Les données immutables c'est bien

parce ce que ça supprime de l'incertitude.

</script></section><section  data-markdown><script type="text/template">
### Incertitude = Bug

</script></section><section  data-markdown><script type="text/template">
#### (Parenthèse)

l'utilisation de `const` ne rend pas la donnée immutable.

Cela empèche juste que la variable puisse être ré-assignée.

Ou pourra toujours modifier les items d'un array ou les clés d'un objet.

</script></section><section  data-markdown><script type="text/template">
#### Des données immutables

Comment éviter de mutter un tableau ?

ne **pas** utiliser `push()`

```js

  const immutablePush = (x, xs) => xs.concat(x)
  // OU
  const immutablePush = (x, xs) => [ ...xs, x]
_
```
modifier un item :
```js

  const immutableSetAtIndex = (index, value, xs) => [
    ...xs.slice(0, index),
    value,
    ...xs.slice(index + 1)
  ]
_
```

</script></section><section  data-markdown><script type="text/template">
#### Des données immutables

Comment éviter de mutter un object ?

```js

  const objectSet = (key, value, obj) =>
    Object.assign({}, obj, { [key]: value })

  // OU

  const objectSet = (key, value, obj) =>
    ({ ...obj, [key]: value })
_
```

</script></section><section  data-markdown><script type="text/template">
#### Des données immutables

### Les lens

Une api plus friendly pour faire de l'immutable.


3 méthodes : `view`, `over` et `set`.
```js
// view :: Lens -> DataStructure -> a
view(lens, dataStructure)

// over :: Lens -> (a -> a) -> DataStructure -> DataStructure
over(lens, mapper, dataStructure)

// set :: Lens -> a -> DataStructure -> DataStructure
set(lens, value, dataStructure)
_
```

</script></section><section  data-markdown><script type="text/template">
#### Des données immutables

Immutable.js

</script></section><section  data-markdown><script type="text/template">
# Bientôt fini !
## plus que Les Setoid,
### Les Semigroup, Les Monoid, Les Functor,
#### Les Apply, Les Applicative, Les Foldable, Les Traversable,
##### Les Chain, Les Monad, Les Extend, Les Comonad ...

</script></section><section  data-markdown><script type="text/template">


<!-- .slide: data-background="http://i.giphy.com/11RUijoqnc1yJW.gif" -->
</script></section><section  data-markdown><script type="text/template">
## Merci

#### de votre attention

</script></section><section  data-markdown><script type="text/template">
## Ressources
- [Eric Elliott - The Two pillars of Javascript - Part 2](https://medium.com/javascript-scene/the-two-pillars-of-javascript-pt-2-functional-programming-a63aa53a41a4#.507emzobw)

- [@mpjme - Youtube channel](https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q)

- [DrBoolean - Mostly Adequate Guide To Functional-Programming](https://drboolean.gitbooks.io/mostly-adequate-guide/content/)

- [Rich Hickey - Simple Made Easy](https://www.youtube.com/watch?v=rI8tNMsozo0)

- [DrBoolean - Hey Underscore, You're Doing It Wrong!](https://www.youtube.com/watch?v=m3svKOdZijA)

- [Brian Beckman: Don't fear the Monad (pour les oufs)](https://www.youtube.com/watch?v=ZhuHCtR3xq8)

- [functinal programming en PHP (no joke)](http://www.phptherightway.com/pages/Functional-Programming.html)

</script></section><section  data-markdown><script type="text/template">
Mon ptit nom c'est **Gabriel Vergnaud**

- [@gvergnaud on Github](https://github.com/gvergnaud)
- [@gabrielvergnaud on Twitter](https://twitter.com/GabrielVergnaud)
- [LinkedIn](https://www.linkedin.com/in/gabriel-vergnaud-09446199)
</script></section></div>
    </div>

    <script src="./lib/js/head.min.js"></script>
    <script src="./js/reveal.js"></script>

    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // Optional libraries used to extend on reveal.js
      var deps = [
        { src: './lib/js/classList.js', condition: function() { return !document.body.classList; } },
        { src: './plugin/markdown/marked.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
        { src: './plugin/markdown/markdown.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
        { src: './plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
        { src: './plugin/zoom-js/zoom.js', async: true },
        { src: './plugin/notes/notes.js', async: true },
        { src: './plugin/math/math.js', async: true }
      ];

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        dependencies: deps
      };

      // options from URL query string
      var queryOptions = Reveal.getQueryHash() || {};

      var options = extend(defaultOptions, {"transition":"slide"}, queryOptions);
    </script>


    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
